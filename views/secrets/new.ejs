<% const content = `
  <main>
    <h1>Create a One-Time Secret</h1>
    <p class="hint">Your secret is encrypted in your browser. The encryption key never leaves your device.</p>
    
    <form id="secret-form">
      <label for="secret-text">Secret Message</label>
      <textarea name="text" id="secret-text" rows="6" placeholder="Enter your secret here..." required></textarea>
      
      <button type="submit">Create Secret</button>
    </form>
    
    <div id="result"></div>
    <p><a href="/">Back to home</a></p>
  </main>

  <script>
    // Generate a random 256-bit key
    async function generateKey() {
      return await crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
    }

    // Export key to base64url
    async function exportKey(key) {
      const raw = await crypto.subtle.exportKey('raw', key);
      return btoa(String.fromCharCode(...new Uint8Array(raw)))
        .replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');
    }

    // Encrypt plaintext with key, returns base64url ciphertext
    async function encrypt(plaintext, key) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoded = new TextEncoder().encode(plaintext);
      const ciphertext = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        encoded
      );
      // Prepend IV to ciphertext
      const combined = new Uint8Array(iv.length + ciphertext.byteLength);
      combined.set(iv);
      combined.set(new Uint8Array(ciphertext), iv.length);
      return btoa(String.fromCharCode(...combined))
        .replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');
    }

    document.getElementById('secret-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = document.getElementById('secret-text').value;
      const resultDiv = document.getElementById('result');
      
      if (!text.trim()) {
        resultDiv.innerHTML = '<p style="color: red;">Please enter a secret.</p>';
        return;
      }

      try {
        // Generate key and encrypt client-side
        const key = await generateKey();
        const keyStr = await exportKey(key);
        const ciphertext = await encrypt(text, key);

        // Send only ciphertext to server
        const response = await fetch('/secrets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: 'ciphertext=' + encodeURIComponent(ciphertext)
        });

        const html = await response.text();
        // Extract the ID from response and append key as fragment
        const match = html.match(/\\/secrets\\/([^"#]+)/);
        if (match) {
          const secretId = match[1];
          const fullUrl = location.origin + '/secrets/' + secretId + '#' + keyStr;
          resultDiv.innerHTML = 
            '<p>Secret created! Share this link (it can only be viewed once):</p>' +
            '<p><a href="' + fullUrl + '">' + fullUrl + '</a></p>' +
            '<p class="hint">The encryption key is in the URL fragment and never sent to the server.</p>';
        } else {
          resultDiv.innerHTML = html;
        }
      } catch (err) {
        resultDiv.innerHTML = '<p style="color: red;">Encryption failed: ' + err.message + '</p>';
      }
    });
  </script>
` %>
<%- include('../layout', { content, title }) %>
